exports.Winterfell=function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=8)}([function(module,exports){eval('module.exports = require("react");\n\n//# sourceURL=webpack://Winterfell/external_%22react%22?')},function(module,exports){eval('module.exports = require("lodash");\n\n//# sourceURL=webpack://Winterfell/external_%22lodash%22?')},function(module,exports){eval('module.exports = require("prop-types");\n\n//# sourceURL=webpack://Winterfell/external_%22prop-types%22?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar errorMessages = {\n  /*\n   * Fallback Error Message\n   */\n  default: 'Please correct the field below',\n\n  /*\n   * Min and Max string left message\n   */\n  isLength: function isLength(validationItem) {\n    switch (validationItem.params.length) {\n      case 1:\n        return 'Please enter a value with at least ' + validationItem.params[0] + ' character' + (validationItem.params[0] != 1 ? 's' : '');\n        break;\n\n      case 2:\n        return 'Please enter a value between ' + validationItem.params[0] + ' and ' + validationItem.params[1] + ' characters long';\n        break;\n\n      default:\n        return errorMessages.default;\n        break;\n    }\n\n    return errorMessage;\n  },\n\n  /*\n   * Valid email address\n   */\n  isEmail: 'Please enter a valid email address',\n\n  /*\n   * String contains seed\n   */\n  contains: function contains(validationItem) {\n    return 'Please enter a value that contains \"' + validationItem.params[0] + '\"';\n  },\n\n  /*\n   * String equals string\n   */\n  equals: function equals(validationItem) {\n    return 'Value must equal ' + validationItem.params[0];\n  },\n\n  /*\n   * Characters A-Z only\n   */\n  isAlpha: 'Please only enter letters',\n\n  /*\n   * Characters A-Z and 1-9 only\n   */\n  isAlphanumeric: 'Please only enter letters and numbers',\n\n  /*\n   * Credit card\n   */\n  isCreditCard: 'Please enter a valid credit card number',\n\n  /*\n   * Currency\n   */\n  isCurrency: 'Please enter a current value only',\n\n  /*\n   * Date\n   */\n  isDate: 'Please enter a valid date',\n\n  /*\n   * Decimal value\n   */\n  isDecimal: 'Please enter a decimal value only',\n\n  /*\n   * Float value\n   */\n  isFloat: 'Please enter a float value only',\n\n  /*\n   * IP value\n   */\n  isIP: 'Please enter a valid IP address',\n\n  /*\n   * isIn array of items\n   */\n  isIn: 'Please enter one of the allowed values',\n\n  /*\n   * isAllIn array of items\n   */\n  isAllIn: 'Please enter one of the allowed values',\n\n  /*\n   * JSON Value\n   */\n  isJSON: 'Please enter a valid JSON string',\n\n  /*\n   * Lowercase values only\n   */\n  isLowercase: 'Please enter lowercase characters only',\n\n  /*\n   * Uppercase values only\n   */\n  isUppercase: 'Please enter uppercase characters only',\n\n  /*\n   * Mobile phone\n   */\n  isMobilePhone: 'Please enter a valid mobile number',\n\n  /*\n   * MongoId only\n   */\n  isMongoId: 'Please enter a valid MongoId',\n\n  /*\n   * Numbers only\n   */\n  isNumeric: 'Please enter numbers only',\n\n  /*\n   * URL Only\n   */\n  isURL: 'Please enter a valid URL',\n\n  /*\n   * isAccepted - checkbox\n   */\n  isAccepted: 'Please accept by clicking the checkbox'\n};\n/**\n * Add a single error message\n *\n * @param  string          type    Error message type\n * @param  string|function message Message or function to get message\n */\n\nerrorMessages.addErrorMessage = function (type, message) {\n  if (typeof type !== 'string') {\n    throw new Error('Winterfell: First parameter of addErrorMessage ' + 'must be of type string');\n  }\n\n  if (typeof message !== 'function' && typeof message !== 'string') {\n    throw new Error('Winterfell: Second parameter of addErrorMessage ' + 'must be of type function or string');\n  }\n\n  setErrorMessage(type, message);\n};\n/**\n * Add multiple error messages\n *\n * @param  object messages Error messages to add. type => func|string\n */\n\n\nerrorMessages.addErrorMessages = function (messages) {\n  if (_typeof(messages) !== 'object') {\n    throw new Error('Winterfell: First parameter of addErrorMessages ' + 'must be of type object');\n  }\n\n  for (var type in messages) {\n    errorMessages.addErrorMessage(type, messages[type]);\n  }\n};\n/**\n * Get an error message for a validationItem\n *\n * @param  object  validationItem Validation error item\n * @return string                 Error message to display\n */\n\n\nerrorMessages.getErrorMessage = function (validationItem) {\n  var errorMessage = typeof validationItem.message !== 'undefined' ? validationItem.message : typeof errorMessages[validationItem.type] !== 'undefined' ? errorMessages[validationItem.type] : errorMessages.default;\n  return typeof errorMessage === 'function' ? errorMessage(validationItem) : errorMessage;\n};\n/**\n * setErrorMessage\n *\n * @param  string          type    Error message type\n * @param  stirng|function message essage or function to get message\n */\n\n\nvar setErrorMessage = function setErrorMessage(type, message) {\n  errorMessages[type] = message;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (errorMessages);\n\n//# sourceURL=webpack://Winterfell/./src/lib/errors.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external \"lodash\"\nvar external_lodash_ = __webpack_require__(1);\nvar external_lodash_default = /*#__PURE__*/__webpack_require__.n(external_lodash_);\n\n// EXTERNAL MODULE: external \"validator\"\nvar external_validator_ = __webpack_require__(5);\nvar external_validator_default = /*#__PURE__*/__webpack_require__.n(external_validator_);\n\n// CONCATENATED MODULE: ./src/lib/stringParser.js\n/* harmony default export */ var stringParser = (function (template, params) {\n  template = template || '';\n  params = params || {};\n  /*\n   * Split up template in to array of characters\n   */\n\n  var characters = template.split('');\n  var buffer = '';\n  var parsedTemplate = '';\n  var collecting = false;\n\n  for (var i = 0; i < characters.length; i++) {\n    var currentChar = characters[i];\n    /*\n     * If we're not collecting and we're not\n     * and opening or closing brace then\n     * append the charater to the\n     * parsedTemplate and move on\n     */\n\n    if (!collecting && currentChar != '{' && currentChar != '}') {\n      parsedTemplate += currentChar;\n      continue;\n    }\n    /*\n     * If we're an opening brace,\n     * start collecting for the buffer\n     */\n\n\n    if (currentChar == '{') {\n      collecting = true;\n    }\n    /*\n     * If we're here, we're collecting so if\n     * we're not a brace of any sort then add\n     * the character to the buffer\n     */\n\n\n    if (currentChar != '{' && currentChar != '}') {\n      buffer += currentChar;\n    }\n    /*\n     * If we're a closing brace, then we\n     * attempt to get the value with the\n     * buffers name from the params object\n     * and add it to the parsedTemplate\n     */\n\n\n    if (currentChar == '}') {\n      var value = '';\n\n      if (typeof params[buffer] !== 'undefined') {\n        value = params[buffer];\n      }\n\n      parsedTemplate += value;\n      /*\n       * Stop collecting and reset\n       * the buffer to nothing\n       */\n\n      collecting = false;\n      buffer = '';\n    }\n  }\n\n  return parsedTemplate;\n});\n// CONCATENATED MODULE: ./src/lib/validation.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateAnswer\", function() { return validation_validateAnswer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActiveQuestions\", function() { return getActiveQuestions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActiveQuestionsFromQuestionSets\", function() { return getActiveQuestionsFromQuestionSets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQuestionPanelInvalidQuestions\", function() { return getQuestionPanelInvalidQuestions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addValidationMethod\", function() { return addValidationMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addValidationMethods\", function() { return addValidationMethods; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"purgeQuestionAnswers\", function() { return validation_purgeQuestionAnswers; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\nvar extraValidators = {\n  /*\n   * isAccepted Validation Mehod\n   */\n  isAccepted: function isAccepted(value, expected) {\n    return value == expected;\n  },\n\n  /*\n   * isAllIn Validation Method\n   */\n  isAllIn: function isAllIn(value, options) {\n    if (!value) {\n      return false;\n    }\n\n    return external_lodash_default.a.every(value, function (item) {\n      return options.indexOf(item) > -1;\n    });\n  }\n};\n/**\n * Validate a value against a validation item\n *\n * @param  any     value          Value being tested\n * @param  object  validationItem Rule set for validator\n * @return boolean                Valid?\n */\n\nvar validation_validateAnswer = function validateAnswer(value, validationItem, questionAnswers) {\n  var validationMethod = typeof extraValidators[validationItem.type] !== 'undefined' ? extraValidators[validationItem.type] : external_validator_default.a.hasOwnProperty(validationItem.type) && typeof external_validator_default.a[validationItem.type] === 'function' ? external_validator_default.a[validationItem.type] : undefined;\n\n  if (!validationMethod) {\n    throw new Error('Winterfell: Attempted to validate for undefined method \"' + validationItem.type + '\"');\n  }\n  /*\n   * Clone the validation parameters so it doesn't effect the\n   * parameters elsewhere by reference.\n   */\n\n\n  var validationParameters = (validationItem.params || []).slice(0);\n  /*\n   * Run the parameters through the stringParser with the\n   * questionAnswers so that it sets the questionAnswer\n   * as the parameter.\n   */\n\n  validationParameters = validationParameters.map(function (p) {\n    return typeof p === 'string' ? stringParser(p, questionAnswers) : p;\n  });\n  /*\n   * Push the value of the question we're validating to\n   * the first parameter of the validationParameters\n   */\n\n  validationParameters.unshift(value);\n  /*\n   * Return the result of the validation method running\n   * wtih the validationParameters.\n   */\n\n  return validationMethod.apply(null, validationParameters);\n};\n/**\n * Get active questions from an array of questions,\n * recursively. Follows active conditions.\n *\n * @param  array  questions       Questions to run through\n * @param  object questionAnswers Current answers for questions\n * @param  array  activeQuestions\n * @return array                  All active questions\n */\n\nvar getActiveQuestions = function getActiveQuestions(questions, questionAnswers, activeQuestions) {\n  activeQuestions = activeQuestions || [];\n  questions.forEach(function (question) {\n    activeQuestions.push({\n      questionId: question.questionId,\n      validations: question.validations\n    });\n\n    if (typeof question.input.options === 'undefined' || question.input.options.length === 0) {\n      return;\n    }\n\n    question.input.options.forEach(function (option) {\n      if (typeof option.conditionalQuestions === 'undefined' || option.conditionalQuestions.length == 0 || questionAnswers[question.questionId] != option.value) {\n        return;\n      }\n\n      activeQuestions = getActiveQuestions(option.conditionalQuestions, questionAnswers, activeQuestions);\n    });\n  });\n  return activeQuestions;\n};\n/**\n * Get active questions from multiple question sets\n *\n * @param  array  questionSets    All question sets\n * @param  object questionAnswers Current answers for questions\n * @return array                  All active questions\n */\n\nvar getActiveQuestionsFromQuestionSets = function getActiveQuestionsFromQuestionSets(questionSets, questionAnswers) {\n  var questionsToCheck = [];\n  questionSets.forEach(function (questionSet) {\n    return Array.prototype.push.apply(questionsToCheck, getActiveQuestions(questionSet.questions, questionAnswers));\n  });\n  return questionsToCheck;\n};\n/**\n * Get all invalid questions from question sets\n *\n * @param  array  questionSets     All question sets\n * @param  object questionAnswers  Current answers for questions\n * @return object                  Set of questions and their invalidations\n */\n\nvar getQuestionPanelInvalidQuestions = function getQuestionPanelInvalidQuestions(questionSets, questionAnswers) {\n  var questionsToCheck = getActiveQuestionsFromQuestionSets(questionSets, questionAnswers).filter(function (question) {\n    return question.validations instanceof Array && question.validations.length > 0;\n  });\n  /*\n   * Now we run validations for the questions\n   * we need to check for errors.\n   *\n   * Go through every question, and its validations\n   * then run the question and answer through\n   * the validation method required.\n   */\n\n  var errors = {};\n  questionsToCheck.forEach(function (_ref) {\n    var questionId = _ref.questionId,\n        validations = _ref.validations;\n    return [].forEach.bind(validations, function (validation) {\n      var valid = validation_validateAnswer(questionAnswers[questionId], validation, questionAnswers);\n\n      if (valid) {\n        return;\n      }\n      /*\n         * If we got here, the validation failed. Add\n         * an validation error and continue to the next!\n         */\n\n\n      if (typeof errors[questionId] === 'undefined') {\n        errors[questionId] = [];\n      }\n\n      errors[questionId].push(validation);\n    })();\n  });\n  return errors;\n};\n/**\n * Add a single validation method\n *\n * @param  string   name   Name of validation method\n * @param  function method Validation method\n */\n\nvar addValidationMethod = function addValidationMethod(name, method) {\n  if (typeof name !== 'string') {\n    throw new Error('Winterfell: First parameter of addValidationMethod ' + 'must be of type string');\n  }\n\n  if (typeof method !== 'function') {\n    throw new Error('Winterfell: Second parameter of addValidationMethod ' + 'must be of type function');\n  }\n\n  extraValidators[name] = method;\n};\n/**\n * Add multiple validation methods\n *\n * @param  array methods Methods to add. name => func\n */\n\nvar addValidationMethods = function addValidationMethods(methods) {\n  if (_typeof(methods) !== 'object') {\n    throw new Error('Winterfell: First parameter of addValidationMethods ' + 'must be of type object');\n  }\n\n  for (var methodName in methods) {\n    addValidationMethod(methodName, methods[methodName]);\n  }\n};\n/**\n * Remove out of scope responses from QuestionAnswers\n *\n * @param  array  questions       Questions to run through\n * @param  object questionAnswers Current answers for questions\n * @param  array  purgeAnswers    Answers to be removed\n * @param  bool   purge           Purge mode for all child answers\n * @return array                  All active questions\n */\n\nvar validation_purgeQuestionAnswers = function purgeQuestionAnswers(questions, questionAnswers, purgeAnswers, purge) {\n  purgeAnswers = purgeAnswers || Object.assign({}, questionAnswers);\n  purge = typeof purge === 'undefined' ? false : purge;\n  questions.forEach(function (question) {\n    if (typeof question.input.options === 'undefined' || question.input.options.length === 0) {\n      if (purge) {\n        purgeAnswers[question.questionId] = null;\n      }\n\n      return;\n    }\n\n    if (purge) {\n      purgeAnswers[question.questionId] = null;\n      question.input.options.forEach(function (option) {\n        if (typeof option.conditionalQuestions !== 'undefined' && option.conditionalQuestions.length !== 0) {\n          purgeAnswers = purgeQuestionAnswers(option.conditionalQuestions, questionAnswers, purgeAnswers, purge);\n        }\n      });\n      return;\n    }\n\n    question.input.options.forEach(function (option) {\n      if (typeof purgeAnswers[question.questionId] !== 'undefined') {\n        var needPurge = false;\n\n        if (Array.isArray(purgeAnswers[question.questionId])) {\n          needPurge = !external_lodash_default.a.contains(purgeAnswers[question.questionId], option.value);\n        } else {\n          needPurge = purgeAnswers[question.questionId] !== option.value;\n        }\n\n        if (typeof option.conditionalQuestions !== 'undefined' && option.conditionalQuestions.length !== 0) {\n          purgeAnswers = purgeQuestionAnswers(option.conditionalQuestions, questionAnswers, purgeAnswers, needPurge);\n        }\n      }\n    });\n  });\n  return external_lodash_default.a.omit(purgeAnswers, function (value, key, object) {\n    return value === null;\n  });\n};\n\n//# sourceURL=webpack://Winterfell/./src/lib/validation.js_+_1_modules?")},function(module,exports){eval('module.exports = require("validator");\n\n//# sourceURL=webpack://Winterfell/external_%22validator%22?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "react"\nvar external_react_ = __webpack_require__(0);\nvar external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);\n\n// CONCATENATED MODULE: ./src/inputTypes/checkboxInput.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar checkboxInput_CheckboxInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(CheckboxInput, _React$Component);\n\n  function CheckboxInput(props) {\n    var _this;\n\n    _classCallCheck(this, CheckboxInput);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CheckboxInput).call(this, props));\n    _this.state = {\n      checked: props.defaultChecked\n    };\n    return _this;\n  }\n\n  _createClass(CheckboxInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      var _this2 = this;\n\n      if (e) {\n        this.setState({\n          checked: !this.state.checked\n        }, function () {\n          _this2.props.onChange(_this2.state.checked ? _this2.props.value : undefined);\n        });\n      } else {\n        this.props.onChange(this.state.checked ? this.props.value : undefined);\n      }\n    }\n  }, {\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      if (this.state.checked) {\n        this.handleChange();\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("div", {\n        className: this.props.classes.checkboxInput\n      }, external_react_default.a.createElement("label", {\n        className: this.props.classes.checkboxLabel,\n        id: this.props.labelId\n      }, external_react_default.a.createElement("input", {\n        type: "checkbox",\n        name: this.props.name,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.checkbox,\n        defaultChecked: this.state.checked,\n        value: this.props.value,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.checked ? this.props.value : undefined)\n      }), this.props.text));\n    }\n  }]);\n\n  return CheckboxInput;\n}(external_react_default.a.Component);\n\ncheckboxInput_CheckboxInput.defaultProps = {\n  text: \'\',\n  defaultChecked: false,\n  classes: {},\n  name: \'\',\n  value: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var checkboxInput = (checkboxInput_CheckboxInput);\n// CONCATENATED MODULE: ./src/lib/cloneArray.js\nvar cloneArray = function cloneArray(array) {\n  return array.slice(0);\n};\n// CONCATENATED MODULE: ./src/inputTypes/checkboxOptionsInput.js\nfunction checkboxOptionsInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { checkboxOptionsInput_typeof = function _typeof(obj) { return typeof obj; }; } else { checkboxOptionsInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return checkboxOptionsInput_typeof(obj); }\n\nfunction checkboxOptionsInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction checkboxOptionsInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction checkboxOptionsInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) checkboxOptionsInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) checkboxOptionsInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction checkboxOptionsInput_possibleConstructorReturn(self, call) { if (call && (checkboxOptionsInput_typeof(call) === "object" || typeof call === "function")) { return call; } return checkboxOptionsInput_assertThisInitialized(self); }\n\nfunction checkboxOptionsInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction checkboxOptionsInput_getPrototypeOf(o) { checkboxOptionsInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return checkboxOptionsInput_getPrototypeOf(o); }\n\nfunction checkboxOptionsInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) checkboxOptionsInput_setPrototypeOf(subClass, superClass); }\n\nfunction checkboxOptionsInput_setPrototypeOf(o, p) { checkboxOptionsInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return checkboxOptionsInput_setPrototypeOf(o, p); }\n\n\n\n\nvar checkboxOptionsInput_CheckboxOptionsInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  checkboxOptionsInput_inherits(CheckboxOptionsInput, _React$Component);\n\n  function CheckboxOptionsInput(props) {\n    var _this;\n\n    checkboxOptionsInput_classCallCheck(this, CheckboxOptionsInput);\n\n    _this = checkboxOptionsInput_possibleConstructorReturn(this, checkboxOptionsInput_getPrototypeOf(CheckboxOptionsInput).call(this, props));\n    _this.state = {\n      value: _this.props.value.length > 0 ? cloneArray(_this.props.value) : []\n    };\n    return _this;\n  }\n\n  checkboxOptionsInput_createClass(CheckboxOptionsInput, [{\n    key: "handleChange",\n    value: function handleChange(newVal, e) {\n      var currentValue = this.state.value;\n\n      if (e.target.checked) {\n        currentValue.push(newVal);\n      } else {\n        currentValue = currentValue.filter(function (v) {\n          return v != newVal;\n        });\n      }\n\n      this.setState({\n        value: currentValue\n      }, this.props.onChange.bind(null, currentValue));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return external_react_default.a.createElement("ul", {\n        className: this.props.classes.checkboxList\n      }, this.props.options.map(function (opt) {\n        return external_react_default.a.createElement("li", {\n          key: opt.value,\n          className: _this2.props.classes.checkboxListItem\n        }, external_react_default.a.createElement("label", {\n          className: _this2.props.classes.checkboxLabel,\n          id: _this2.props.labelId\n        }, external_react_default.a.createElement("input", {\n          type: "checkbox",\n          name: _this2.props.name,\n          "aria-labelledby": _this2.props.labelId,\n          value: opt.value,\n          checked: _this2.state.value.indexOf(opt.value) > -1,\n          className: _this2.props.classes.checkbox,\n          required: _this2.props.required ? \'required\' : undefined,\n          onChange: _this2.handleChange.bind(_this2, opt.value),\n          onBlur: _this2.props.onBlur.bind(null, _this2.state.value)\n        }), opt.text));\n      }));\n    }\n  }]);\n\n  return CheckboxOptionsInput;\n}(external_react_default.a.Component);\n\ncheckboxOptionsInput_CheckboxOptionsInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  value: [],\n  options: [],\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var checkboxOptionsInput = (checkboxOptionsInput_CheckboxOptionsInput);\n// CONCATENATED MODULE: ./src/inputTypes/emailInput.js\nfunction emailInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { emailInput_typeof = function _typeof(obj) { return typeof obj; }; } else { emailInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return emailInput_typeof(obj); }\n\nfunction emailInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction emailInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction emailInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) emailInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) emailInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction emailInput_possibleConstructorReturn(self, call) { if (call && (emailInput_typeof(call) === "object" || typeof call === "function")) { return call; } return emailInput_assertThisInitialized(self); }\n\nfunction emailInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction emailInput_getPrototypeOf(o) { emailInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return emailInput_getPrototypeOf(o); }\n\nfunction emailInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) emailInput_setPrototypeOf(subClass, superClass); }\n\nfunction emailInput_setPrototypeOf(o, p) { emailInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return emailInput_setPrototypeOf(o, p); }\n\n\n\nvar emailInput_EmailInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  emailInput_inherits(EmailInput, _React$Component);\n\n  function EmailInput(props) {\n    var _this;\n\n    emailInput_classCallCheck(this, EmailInput);\n\n    _this = emailInput_possibleConstructorReturn(this, emailInput_getPrototypeOf(EmailInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  emailInput_createClass(EmailInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("input", {\n        type: "email",\n        name: this.props.name,\n        id: this.props.id,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.input,\n        placeholder: this.props.placeholder,\n        value: this.state.value,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value),\n        onKeyDown: this.props.onKeyDown\n      });\n    }\n  }]);\n\n  return EmailInput;\n}(external_react_default.a.Component);\n\nemailInput_EmailInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  placeholder: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {},\n  onKeyDown: function onKeyDown() {}\n};\n/* harmony default export */ var emailInput = (emailInput_EmailInput);\n// CONCATENATED MODULE: ./src/inputTypes/fileInput.js\nfunction fileInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { fileInput_typeof = function _typeof(obj) { return typeof obj; }; } else { fileInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return fileInput_typeof(obj); }\n\nfunction fileInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction fileInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction fileInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) fileInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) fileInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction fileInput_possibleConstructorReturn(self, call) { if (call && (fileInput_typeof(call) === "object" || typeof call === "function")) { return call; } return fileInput_assertThisInitialized(self); }\n\nfunction fileInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction fileInput_getPrototypeOf(o) { fileInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return fileInput_getPrototypeOf(o); }\n\nfunction fileInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) fileInput_setPrototypeOf(subClass, superClass); }\n\nfunction fileInput_setPrototypeOf(o, p) { fileInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return fileInput_setPrototypeOf(o, p); }\n\n\n\nvar fileInput_FileInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  fileInput_inherits(FileInput, _React$Component);\n\n  function FileInput(props) {\n    var _this;\n\n    fileInput_classCallCheck(this, FileInput);\n\n    _this = fileInput_possibleConstructorReturn(this, fileInput_getPrototypeOf(FileInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  fileInput_createClass(FileInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("input", {\n        type: "file",\n        name: this.props.name,\n        id: this.props.id,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.file,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value)\n      });\n    }\n  }]);\n\n  return FileInput;\n}(external_react_default.a.Component);\n\nfileInput_FileInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var fileInput = (fileInput_FileInput);\n// CONCATENATED MODULE: ./src/inputTypes/hiddenInput.js\nfunction hiddenInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hiddenInput_typeof = function _typeof(obj) { return typeof obj; }; } else { hiddenInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hiddenInput_typeof(obj); }\n\nfunction hiddenInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction hiddenInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction hiddenInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) hiddenInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) hiddenInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction hiddenInput_possibleConstructorReturn(self, call) { if (call && (hiddenInput_typeof(call) === "object" || typeof call === "function")) { return call; } return hiddenInput_assertThisInitialized(self); }\n\nfunction hiddenInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction hiddenInput_getPrototypeOf(o) { hiddenInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return hiddenInput_getPrototypeOf(o); }\n\nfunction hiddenInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) hiddenInput_setPrototypeOf(subClass, superClass); }\n\nfunction hiddenInput_setPrototypeOf(o, p) { hiddenInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return hiddenInput_setPrototypeOf(o, p); }\n\n\n\nvar hiddenInput_HiddenInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  hiddenInput_inherits(HiddenInput, _React$Component);\n\n  function HiddenInput(props) {\n    var _this;\n\n    hiddenInput_classCallCheck(this, HiddenInput);\n\n    _this = hiddenInput_possibleConstructorReturn(this, hiddenInput_getPrototypeOf(HiddenInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  hiddenInput_createClass(HiddenInput, [{\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("input", {\n        type: "hidden",\n        name: this.props.name,\n        value: this.state.value\n      });\n    }\n  }]);\n\n  return HiddenInput;\n}(external_react_default.a.Component);\n\nhiddenInput_HiddenInput.defaultProps = {\n  name: \'\',\n  value: \'\'\n};\n/* harmony default export */ var hiddenInput = (hiddenInput_HiddenInput);\n// CONCATENATED MODULE: ./src/inputTypes/passwordInput.js\nfunction passwordInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { passwordInput_typeof = function _typeof(obj) { return typeof obj; }; } else { passwordInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return passwordInput_typeof(obj); }\n\nfunction passwordInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction passwordInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction passwordInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) passwordInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) passwordInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction passwordInput_possibleConstructorReturn(self, call) { if (call && (passwordInput_typeof(call) === "object" || typeof call === "function")) { return call; } return passwordInput_assertThisInitialized(self); }\n\nfunction passwordInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction passwordInput_getPrototypeOf(o) { passwordInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return passwordInput_getPrototypeOf(o); }\n\nfunction passwordInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) passwordInput_setPrototypeOf(subClass, superClass); }\n\nfunction passwordInput_setPrototypeOf(o, p) { passwordInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return passwordInput_setPrototypeOf(o, p); }\n\n\n\nvar passwordInput_PasswordInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  passwordInput_inherits(PasswordInput, _React$Component);\n\n  function PasswordInput(props) {\n    var _this;\n\n    passwordInput_classCallCheck(this, PasswordInput);\n\n    _this = passwordInput_possibleConstructorReturn(this, passwordInput_getPrototypeOf(PasswordInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  passwordInput_createClass(PasswordInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("input", {\n        type: "password",\n        name: this.props.name,\n        id: this.props.id,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.input,\n        placeholder: this.props.placeholder,\n        value: this.state.value,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value),\n        onKeyDown: this.props.onKeyDown\n      });\n    }\n  }]);\n\n  return PasswordInput;\n}(external_react_default.a.Component);\n\npasswordInput_PasswordInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  placeholder: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {},\n  onKeyDown: function onKeyDown() {}\n};\n/* harmony default export */ var passwordInput = (passwordInput_PasswordInput);\n// CONCATENATED MODULE: ./src/inputTypes/radioOptionsInput.js\nfunction radioOptionsInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radioOptionsInput_typeof = function _typeof(obj) { return typeof obj; }; } else { radioOptionsInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radioOptionsInput_typeof(obj); }\n\nfunction radioOptionsInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction radioOptionsInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction radioOptionsInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) radioOptionsInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) radioOptionsInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction radioOptionsInput_possibleConstructorReturn(self, call) { if (call && (radioOptionsInput_typeof(call) === "object" || typeof call === "function")) { return call; } return radioOptionsInput_assertThisInitialized(self); }\n\nfunction radioOptionsInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction radioOptionsInput_getPrototypeOf(o) { radioOptionsInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radioOptionsInput_getPrototypeOf(o); }\n\nfunction radioOptionsInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radioOptionsInput_setPrototypeOf(subClass, superClass); }\n\nfunction radioOptionsInput_setPrototypeOf(o, p) { radioOptionsInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radioOptionsInput_setPrototypeOf(o, p); }\n\n\n\nvar radioOptionsInput_RadioOptionsInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  radioOptionsInput_inherits(RadioOptionsInput, _React$Component);\n\n  function RadioOptionsInput(props) {\n    var _this;\n\n    radioOptionsInput_classCallCheck(this, RadioOptionsInput);\n\n    _this = radioOptionsInput_possibleConstructorReturn(this, radioOptionsInput_getPrototypeOf(RadioOptionsInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  radioOptionsInput_createClass(RadioOptionsInput, [{\n    key: "handleChange",\n    value: function handleChange(value) {\n      this.setState({\n        value: value\n      }, this.props.onChange.bind(null, value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return external_react_default.a.createElement("ul", {\n        className: this.props.classes.radioList\n      }, this.props.options.map(function (opt) {\n        return external_react_default.a.createElement("li", {\n          key: opt.value,\n          className: _this2.props.classes.radioListItem\n        }, external_react_default.a.createElement("label", {\n          className: _this2.props.classes.radioLabel,\n          id: _this2.props.labelId\n        }, external_react_default.a.createElement("input", {\n          type: "radio",\n          name: _this2.props.name,\n          "aria-labelledby": _this2.props.labelId,\n          checked: _this2.state.value == opt.value,\n          className: _this2.props.classes.radio,\n          required: _this2.props.required ? \'required\' : undefined,\n          onChange: _this2.handleChange.bind(_this2, opt.value),\n          onBlur: _this2.props.onBlur.bind(null, _this2.state.value)\n        }), opt.text));\n      }));\n    }\n  }]);\n\n  return RadioOptionsInput;\n}(external_react_default.a.Component);\n\nradioOptionsInput_RadioOptionsInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  value: \'\',\n  options: [],\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var radioOptionsInput = (radioOptionsInput_RadioOptionsInput);\n// CONCATENATED MODULE: ./src/inputTypes/selectInput.js\nfunction selectInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { selectInput_typeof = function _typeof(obj) { return typeof obj; }; } else { selectInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return selectInput_typeof(obj); }\n\nfunction selectInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction selectInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction selectInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) selectInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) selectInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction selectInput_possibleConstructorReturn(self, call) { if (call && (selectInput_typeof(call) === "object" || typeof call === "function")) { return call; } return selectInput_assertThisInitialized(self); }\n\nfunction selectInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction selectInput_getPrototypeOf(o) { selectInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selectInput_getPrototypeOf(o); }\n\nfunction selectInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selectInput_setPrototypeOf(subClass, superClass); }\n\nfunction selectInput_setPrototypeOf(o, p) { selectInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selectInput_setPrototypeOf(o, p); }\n\n\n\nvar selectInput_SelectInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  selectInput_inherits(SelectInput, _React$Component);\n\n  function SelectInput(props) {\n    var _this;\n\n    selectInput_classCallCheck(this, SelectInput);\n\n    _this = selectInput_possibleConstructorReturn(this, selectInput_getPrototypeOf(SelectInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  selectInput_createClass(SelectInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var options = this.props.options.map(function (opt) {\n        return external_react_default.a.createElement("option", {\n          key: opt.value,\n          value: opt.value\n        }, opt.text);\n      });\n      return external_react_default.a.createElement("select", {\n        name: this.props.name,\n        id: this.props.id,\n        className: this.props.classes.select,\n        value: this.state.value,\n        ref: "select",\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value)\n      }, options);\n    }\n  }, {\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      /*\n       * Selects automatically pick the first item, so\n       * make sure we set it.\n       */\n      this.handleChange({\n        target: {\n          value: this.refs.select.value\n        }\n      });\n    }\n  }]);\n\n  return SelectInput;\n}(external_react_default.a.Component);\n\nselectInput_SelectInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  options: [],\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var selectInput = (selectInput_SelectInput);\n// CONCATENATED MODULE: ./src/inputTypes/textareaInput.js\nfunction textareaInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { textareaInput_typeof = function _typeof(obj) { return typeof obj; }; } else { textareaInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return textareaInput_typeof(obj); }\n\nfunction textareaInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction textareaInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction textareaInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) textareaInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) textareaInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction textareaInput_possibleConstructorReturn(self, call) { if (call && (textareaInput_typeof(call) === "object" || typeof call === "function")) { return call; } return textareaInput_assertThisInitialized(self); }\n\nfunction textareaInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction textareaInput_getPrototypeOf(o) { textareaInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return textareaInput_getPrototypeOf(o); }\n\nfunction textareaInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) textareaInput_setPrototypeOf(subClass, superClass); }\n\nfunction textareaInput_setPrototypeOf(o, p) { textareaInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return textareaInput_setPrototypeOf(o, p); }\n\n\n\nvar textareaInput_TextareaInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  textareaInput_inherits(TextareaInput, _React$Component);\n\n  function TextareaInput(props) {\n    var _this;\n\n    textareaInput_classCallCheck(this, TextareaInput);\n\n    _this = textareaInput_possibleConstructorReturn(this, textareaInput_getPrototypeOf(TextareaInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  textareaInput_createClass(TextareaInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("textarea", {\n        type: "text",\n        name: this.props.name,\n        id: this.props.id,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.input,\n        placeholder: this.props.placeholder,\n        value: this.state.value,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value)\n      });\n    }\n  }]);\n\n  return TextareaInput;\n}(external_react_default.a.Component);\n\ntextareaInput_TextareaInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  placeholder: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {}\n};\n/* harmony default export */ var textareaInput = (textareaInput_TextareaInput);\n// CONCATENATED MODULE: ./src/inputTypes/textInput.js\nfunction textInput_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { textInput_typeof = function _typeof(obj) { return typeof obj; }; } else { textInput_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return textInput_typeof(obj); }\n\nfunction textInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction textInput_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction textInput_createClass(Constructor, protoProps, staticProps) { if (protoProps) textInput_defineProperties(Constructor.prototype, protoProps); if (staticProps) textInput_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction textInput_possibleConstructorReturn(self, call) { if (call && (textInput_typeof(call) === "object" || typeof call === "function")) { return call; } return textInput_assertThisInitialized(self); }\n\nfunction textInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction textInput_getPrototypeOf(o) { textInput_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return textInput_getPrototypeOf(o); }\n\nfunction textInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) textInput_setPrototypeOf(subClass, superClass); }\n\nfunction textInput_setPrototypeOf(o, p) { textInput_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return textInput_setPrototypeOf(o, p); }\n\n\n\nvar textInput_TextInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  textInput_inherits(TextInput, _React$Component);\n\n  function TextInput(props) {\n    var _this;\n\n    textInput_classCallCheck(this, TextInput);\n\n    _this = textInput_possibleConstructorReturn(this, textInput_getPrototypeOf(TextInput).call(this, props));\n    _this.state = {\n      value: _this.props.value\n    };\n    return _this;\n  }\n\n  textInput_createClass(TextInput, [{\n    key: "handleChange",\n    value: function handleChange(e) {\n      this.setState({\n        value: e.target.value\n      }, this.props.onChange.bind(null, e.target.value));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("input", {\n        type: "text",\n        name: this.props.name,\n        id: this.props.id,\n        "aria-labelledby": this.props.labelId,\n        className: this.props.classes.input,\n        placeholder: this.props.placeholder,\n        value: this.state.value,\n        required: this.props.required ? \'required\' : undefined,\n        onChange: this.handleChange.bind(this),\n        onBlur: this.props.onBlur.bind(null, this.state.value),\n        onKeyDown: this.props.onKeyDown\n      });\n    }\n  }]);\n\n  return TextInput;\n}(external_react_default.a.Component);\n\ntextInput_TextInput.defaultProps = {\n  classes: {},\n  name: \'\',\n  id: \'\',\n  value: \'\',\n  placeholder: \'\',\n  onChange: function onChange() {},\n  onBlur: function onBlur() {},\n  onKeyDown: function onKeyDown() {}\n};\n/* harmony default export */ var textInput = (textInput_TextInput);\n// CONCATENATED MODULE: ./src/inputTypes/index.js\nfunction inputTypes_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { inputTypes_typeof = function _typeof(obj) { return typeof obj; }; } else { inputTypes_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return inputTypes_typeof(obj); }\n\n\n\n\n\n\n\n\n\n\n\n\nvar inputTypes = {\n  checkboxInput: checkboxInput,\n  checkboxOptionsInput: checkboxOptionsInput,\n  emailInput: emailInput,\n  fileInput: fileInput,\n  hiddenInput: hiddenInput,\n  passwordInput: passwordInput,\n  radioOptionsInput: radioOptionsInput,\n  selectInput: selectInput,\n  textareaInput: textareaInput,\n  textInput: textInput\n};\n/**\n * Add an input type\n *\n * @param  type      name     Name of InputType\n * @param  Component instance Input Type Component\n */\n\ninputTypes.addInputType = function (name, instance) {\n  if (typeof name !== \'string\') {\n    throw new Error(\'Winterfell: First parameter of addInputType \' + \'must be of type string\');\n  }\n\n  if (!external_react_default.a.Component instanceof instance.constructor) {\n    throw new Error(\'Winterfell: Cannot not assign "\' + name + \'" as an inputType. \' + \'Second paramter expects a React component\');\n  }\n\n  inputTypes[name] = instance;\n};\n/**\n * Add multiple InputTypes\n *\n * @param  object types InputTypes to add. string => Component\n */\n\n\ninputTypes.addInputTypes = function (types) {\n  if (inputTypes_typeof(types) !== \'object\') {\n    throw new Error(\'Winterfell: First parameter of addInputTypes \' + \'must be of type object\');\n  }\n\n  for (var type in types) {\n    inputTypes.addInputType(type, types[type]);\n  }\n};\n\n/* harmony default export */ var src_inputTypes = __webpack_exports__["default"] = (inputTypes);\n\n//# sourceURL=webpack://Winterfell/./src/inputTypes/index.js_+_11_modules?')},function(module,exports){eval('module.exports = require("keycodez");\n\n//# sourceURL=webpack://Winterfell/external_%22keycodez%22?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "react"\nvar external_react_ = __webpack_require__(0);\nvar external_react_default = /*#__PURE__*/__webpack_require__.n(external_react_);\n\n// EXTERNAL MODULE: external "prop-types"\nvar external_prop_types_ = __webpack_require__(2);\nvar external_prop_types_default = /*#__PURE__*/__webpack_require__.n(external_prop_types_);\n\n// EXTERNAL MODULE: external "lodash"\nvar external_lodash_ = __webpack_require__(1);\nvar external_lodash_default = /*#__PURE__*/__webpack_require__.n(external_lodash_);\n\n// EXTERNAL MODULE: external "keycodez"\nvar external_keycodez_ = __webpack_require__(7);\nvar external_keycodez_default = /*#__PURE__*/__webpack_require__.n(external_keycodez_);\n\n// EXTERNAL MODULE: ./src/lib/validation.js + 1 modules\nvar lib_validation = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./src/lib/errors.js\nvar errors = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./src/button.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n// @ts-check\n\n\nvar button_Button =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Button, _React$Component);\n\n  function Button() {\n    _classCallCheck(this, Button);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Button).apply(this, arguments));\n  }\n\n  _createClass(Button, [{\n    key: "handleClick",\n    value: function handleClick(e) {\n      e.preventDefault();\n      this.props.onClick();\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      return external_react_default.a.createElement("button", {\n        className: this.props.className,\n        onClick: this.handleClick.bind(this)\n      }, this.props.text);\n    }\n  }]);\n\n  return Button;\n}(external_react_default.a.Component);\n\nbutton_Button.defaultProps = {\n  text: \'Submit\',\n  className: undefined,\n  onClick: function onClick() {}\n};\n/* harmony default export */ var src_button = (button_Button);\n// EXTERNAL MODULE: ./src/inputTypes/index.js + 11 modules\nvar inputTypes = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./src/question.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction question_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { question_typeof = function _typeof(obj) { return typeof obj; }; } else { question_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return question_typeof(obj); }\n\nfunction question_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction question_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction question_createClass(Constructor, protoProps, staticProps) { if (protoProps) question_defineProperties(Constructor.prototype, protoProps); if (staticProps) question_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction question_possibleConstructorReturn(self, call) { if (call && (question_typeof(call) === "object" || typeof call === "function")) { return call; } return question_assertThisInitialized(self); }\n\nfunction question_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction question_getPrototypeOf(o) { question_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return question_getPrototypeOf(o); }\n\nfunction question_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) question_setPrototypeOf(subClass, superClass); }\n\nfunction question_setPrototypeOf(o, p) { question_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return question_setPrototypeOf(o, p); }\n\n// @ts-check\n // import _ from \'lodash\';\n\n\n\nvar question_Question =\n/*#__PURE__*/\nfunction (_React$Component) {\n  question_inherits(Question, _React$Component);\n\n  function Question() {\n    question_classCallCheck(this, Question);\n\n    return question_possibleConstructorReturn(this, question_getPrototypeOf(Question).apply(this, arguments));\n  }\n\n  question_createClass(Question, [{\n    key: "handleInputChange",\n    value: function handleInputChange(questionId, value) {\n      this.props.onAnswerChange(questionId, value, this.props.validations, this.props.validateOn, this.props.questionSetId);\n    }\n  }, {\n    key: "handleInputBlur",\n    value: function handleInputBlur(questionId, value) {\n      this.props.onQuestionBlur(questionId, value, this.props.validations, this.props.validateOn);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this = this;\n\n      var Input = inputTypes["default"][this.props.input.type];\n\n      if (!Input) {\n        throw new Error(\'Winterfell: Input Type "\' + this.props.input.type + \'" not defined as Winterfell Input Type\');\n      }\n      /*\n       * Conditional Questions\n       *\n       * Go through the inputs options and filter them down\n       * to options where the value matches the current questions\n       * value. If we have conditional questions on a given option,\n       * then render this component with the props for the conditional\n       * question.\n       */\n\n\n      var conditionalItems = [];\n\n      if (typeof this.props.input.options !== \'undefined\') {\n        this.props.input.options.filter(function (option) {\n          return _this.props.value instanceof Array ? _this.props.value.indexOf(option.value) > -1 : _this.props.value == option.value;\n        }).filter(function (option) {\n          return typeof option.conditionalQuestions !== \'undefined\' && option.conditionalQuestions.length > 0;\n        }).forEach(function (option) {\n          return [].forEach.bind(option.conditionalQuestions, function (conditionalQuestion) {\n            conditionalItems.push(external_react_default.a.createElement(Question, {\n              key: conditionalQuestion.questionId,\n              questionSetId: _this.props.questionSetId,\n              questionId: conditionalQuestion.questionId,\n              question: conditionalQuestion.question,\n              text: conditionalQuestion.text,\n              postText: conditionalQuestion.postText,\n              validateOn: conditionalQuestion.validateOn,\n              validations: conditionalQuestion.validations,\n              value: _this.props.questionAnswers[conditionalQuestion.questionId],\n              input: conditionalQuestion.input,\n              classes: _this.props.classes,\n              renderError: _this.props.renderError,\n              questionAnswers: _this.props.questionAnswers,\n              validationErrors: _this.props.validationErrors,\n              onAnswerChange: _this.props.onAnswerChange,\n              onQuestionBlur: _this.props.onQuestionBlur,\n              onKeyDown: _this.props.onKeyDown\n            }));\n          })();\n        });\n      } // Get the current value. If none is set, then use\n      // the default if given.\n\n\n      var value = typeof this.props.value !== \'undefined\' ? this.props.value : typeof this.props.input.default !== \'undefined\' ? this.props.input.default : undefined; // Retrieve the validation errors for the\n      // current question and map them in to\n      // error-message blocks.\n\n      var validationErrors = typeof this.props.validationErrors[this.props.questionId] !== \'undefined\' ? this.props.validationErrors[this.props.questionId].map(function (error) {\n        return typeof _this.props.renderError === \'function\' ? _this.props.renderError(error, _this.props.questionId) : external_react_default.a.createElement("div", {\n          key: _this.props.questionId + \'Error\' + error.type,\n          className: _this.props.classes.errorMessage\n        }, error.message);\n      }) : [];\n      var labelId = "".concat(this.props.questionId, "-label");\n      return external_react_default.a.createElement("div", {\n        className: this.props.classes.question\n      }, !!this.props.question ? external_react_default.a.createElement("label", {\n        className: this.props.classes.label,\n        id: labelId,\n        htmlFor: this.props.questionId\n      }, this.props.question, typeof this.props.renderRequiredAsterisk !== \'undefined\' && this.props.input.required ? this.props.renderRequiredAsterisk() : undefined) : undefined, !!this.props.text ? external_react_default.a.createElement("p", {\n        className: this.props.classes.questionText\n      }, this.props.text) : undefined, validationErrors, external_react_default.a.createElement(Input, _extends({\n        name: this.props.questionId,\n        id: this.props.questionId,\n        labelId: labelId,\n        value: value,\n        text: this.props.input.text,\n        options: this.props.input.options,\n        placeholder: this.props.input.placeholder,\n        required: this.props.input.required,\n        classes: this.props.classes,\n        onChange: this.handleInputChange.bind(this, this.props.questionId),\n        onBlur: this.handleInputBlur.bind(this, this.props.questionId),\n        onKeyDown: this.props.onKeyDown\n      }, question_typeof(this.props.input.props) === \'object\' ? this.props.input.props : {})), !!this.props.postText ? external_react_default.a.createElement("p", {\n        className: this.props.classes.questionPostText\n      }, this.props.postText) : undefined, conditionalItems);\n    }\n  }, {\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      if (typeof this.props.input.default === \'undefined\' || this.props.input.type === \'checkboxInput\' && typeof this.props.questionAnswers[this.props.questionId] === \'undefined\') {\n        return;\n      }\n\n      this.handleInputChange.call(this, this.props.questionId, this.props.input.default);\n    }\n  }]);\n\n  return Question;\n}(external_react_default.a.Component);\n\nquestion_Question.defaultProps = {\n  questionSetId: undefined,\n  questionId: undefined,\n  question: \'\',\n  validateOn: \'blur\',\n  validations: [],\n  text: undefined,\n  postText: undefined,\n  value: undefined,\n  input: {\n    default: undefined,\n    type: \'textInput\',\n    limit: undefined,\n    placeholder: undefined\n  },\n  classes: {},\n  questionAnswers: {},\n  validationErrors: {},\n  onAnswerChange: function onAnswerChange() {},\n  onQuestionBlur: function onQuestionBlur() {},\n  onKeyDown: function onKeyDown() {},\n  renderError: undefined,\n  renderRequiredAsterisk: undefined\n};\n/* harmony default export */ var src_question = (question_Question);\n// CONCATENATED MODULE: ./src/questionSet.js\nfunction questionSet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { questionSet_typeof = function _typeof(obj) { return typeof obj; }; } else { questionSet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return questionSet_typeof(obj); }\n\nfunction questionSet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction questionSet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction questionSet_createClass(Constructor, protoProps, staticProps) { if (protoProps) questionSet_defineProperties(Constructor.prototype, protoProps); if (staticProps) questionSet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction questionSet_possibleConstructorReturn(self, call) { if (call && (questionSet_typeof(call) === "object" || typeof call === "function")) { return call; } return questionSet_assertThisInitialized(self); }\n\nfunction questionSet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction questionSet_getPrototypeOf(o) { questionSet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return questionSet_getPrototypeOf(o); }\n\nfunction questionSet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) questionSet_setPrototypeOf(subClass, superClass); }\n\nfunction questionSet_setPrototypeOf(o, p) { questionSet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return questionSet_setPrototypeOf(o, p); }\n\n// @ts-check\n // import _ from \'lodash\';\n\n\n\nvar questionSet_QuestionSet =\n/*#__PURE__*/\nfunction (_React$Component) {\n  questionSet_inherits(QuestionSet, _React$Component);\n\n  function QuestionSet() {\n    questionSet_classCallCheck(this, QuestionSet);\n\n    return questionSet_possibleConstructorReturn(this, questionSet_getPrototypeOf(QuestionSet).apply(this, arguments));\n  }\n\n  questionSet_createClass(QuestionSet, [{\n    key: "render",\n    value: function render() {\n      var _this = this;\n\n      var questions = this.props.questions.map(function (question) {\n        return external_react_default.a.createElement(src_question, {\n          key: question.questionId,\n          questionSetId: _this.props.id,\n          questionId: question.questionId,\n          question: question.question,\n          validateOn: question.validateOn,\n          validations: question.validations,\n          text: question.text,\n          postText: question.postText,\n          value: _this.props.questionAnswers[question.questionId],\n          input: question.input,\n          classes: _this.props.classes,\n          renderError: _this.props.renderError,\n          renderRequiredAsterisk: _this.props.renderRequiredAsterisk,\n          questionAnswers: _this.props.questionAnswers,\n          validationErrors: _this.props.validationErrors,\n          onAnswerChange: _this.props.onAnswerChange,\n          onQuestionBlur: _this.props.onQuestionBlur,\n          onKeyDown: _this.props.onKeyDown\n        });\n      });\n      return external_react_default.a.createElement("div", {\n        className: this.props.classes.questionSet\n      }, typeof this.props.questionSetHeader !== \'undefined\' || typeof this.props.questionSetText !== \'undefined\' ? external_react_default.a.createElement("div", {\n        className: this.props.classes.questionSetHeaderContainer\n      }, typeof this.props.questionSetHeader !== \'undefined\' ? external_react_default.a.createElement("h4", {\n        className: this.props.classes.questionSetHeader\n      }, this.props.questionSetHeader) : undefined, typeof this.props.questionSetText !== \'undefined\' ? external_react_default.a.createElement("p", {\n        className: this.props.classes.questionSetText\n      }, this.props.questionSetText) : undefined) : undefined, questions);\n    }\n  }]);\n\n  return QuestionSet;\n}(external_react_default.a.Component);\n\nquestionSet_QuestionSet.defaultProps = {\n  id: undefined,\n  name: \'\',\n  questionSetHeader: undefined,\n  questionSetText: undefined,\n  questions: [],\n  questionAnswers: {},\n  classes: {},\n  validationErrors: {},\n  renderError: undefined,\n  renderRequiredAsterisk: undefined,\n  onAnswerChange: function onAnswerChange() {},\n  onQuestionBlur: function onQuestionBlur() {},\n  onKeyDown: function onKeyDown() {}\n};\n/* harmony default export */ var src_questionSet = (questionSet_QuestionSet);\n// CONCATENATED MODULE: ./src/questionPanel.js\nfunction questionPanel_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { questionPanel_typeof = function _typeof(obj) { return typeof obj; }; } else { questionPanel_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return questionPanel_typeof(obj); }\n\nfunction questionPanel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction questionPanel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction questionPanel_createClass(Constructor, protoProps, staticProps) { if (protoProps) questionPanel_defineProperties(Constructor.prototype, protoProps); if (staticProps) questionPanel_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction questionPanel_possibleConstructorReturn(self, call) { if (call && (questionPanel_typeof(call) === "object" || typeof call === "function")) { return call; } return questionPanel_assertThisInitialized(self); }\n\nfunction questionPanel_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction questionPanel_getPrototypeOf(o) { questionPanel_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return questionPanel_getPrototypeOf(o); }\n\nfunction questionPanel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) questionPanel_setPrototypeOf(subClass, superClass); }\n\nfunction questionPanel_setPrototypeOf(o, p) { questionPanel_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return questionPanel_setPrototypeOf(o, p); }\n\n// @ts-check\n\n\n\n\n\n\n\n\nvar questionPanel_QuestionPanel =\n/*#__PURE__*/\nfunction (_React$Component) {\n  questionPanel_inherits(QuestionPanel, _React$Component);\n\n  function QuestionPanel(props) {\n    var _this;\n\n    questionPanel_classCallCheck(this, QuestionPanel);\n\n    _this = questionPanel_possibleConstructorReturn(this, questionPanel_getPrototypeOf(QuestionPanel).call(this, props));\n    _this.state = {\n      validationErrors: _this.props.validationErrors\n    };\n    return _this;\n  }\n\n  questionPanel_createClass(QuestionPanel, [{\n    key: "handleAnswerValidate",\n    value: function handleAnswerValidate(questionId, questionAnswer, validations) {\n      var _this2 = this;\n\n      if (typeof validations === \'undefined\' || validations.length === 0) {\n        return;\n      }\n      /*\n       * Run the question through its validations and\n       * show any error messages if invalid.\n       */\n\n\n      var questionValidationErrors = [];\n      validations.forEach(function (validation) {\n        if (lib_validation["validateAnswer"](questionAnswer, validation, _this2.props.questionAnswers)) {\n          return;\n        }\n\n        questionValidationErrors.push({\n          type: validation.type,\n          message: errors["default"].getErrorMessage(validation)\n        });\n      });\n\n      var validationErrors = external_lodash_default.a.chain(this.state.validationErrors).set(questionId, questionValidationErrors).value();\n\n      this.setState({\n        validationErrors: validationErrors\n      });\n    }\n  }, {\n    key: "handleMainButtonClick",\n    value: function handleMainButtonClick() {\n      var _this3 = this;\n\n      var action = this.props.action.default;\n      var conditions = this.props.action.conditions || [];\n      /*\n       * We need to get all the question sets for this panel.\n       * Collate a list of the question set IDs required\n       * and run through the schema to grab the question sets.\n       */\n\n      var questionSetIds = this.props.questionSets.map(function (qS) {\n        return qS.questionSetId;\n      });\n\n      var questionSets = external_lodash_default.a.chain(this.props.schema.questionSets).filter(function (qS) {\n        return questionSetIds.indexOf(qS.questionSetId) > -1;\n      }).value();\n      /*\n       * Get any incorrect fields that need error messages.\n       */\n\n\n      var invalidQuestions = lib_validation["getQuestionPanelInvalidQuestions"](questionSets, this.props.questionAnswers);\n      /*\n       * If the panel isn\'t valid...\n       */\n\n      if (Object.keys(invalidQuestions).length > 0) {\n        var validationErrors = external_lodash_default.a.mapValues(invalidQuestions, function (validations) {\n          return validations.map(function (validation) {\n            return {\n              type: validation.type,\n              message: errors["default"].getErrorMessage(validation)\n            };\n          });\n        });\n\n        this.setState({\n          validationErrors: validationErrors\n        });\n        return;\n      }\n      /*\n       * Panel is valid. So what do we do next?\n       * Check our conditions and act upon them, or the default.\n       */\n\n\n      conditions.forEach(function (condition) {\n        var answer = _this3.props.questionAnswers[condition.questionId];\n        action = answer == condition.value ? {\n          action: condition.action,\n          target: condition.target\n        } : action;\n      });\n      /*\n       * Decide which action to take depending on\n       * the action decided upon.\n       */\n\n      switch (action.action) {\n        case \'GOTO\':\n          this.props.onSwitchPanel(action.target);\n          break;\n\n        case \'SUBMIT\':\n          this.props.onSubmit(action.target);\n          break;\n      }\n    }\n  }, {\n    key: "handleBackButtonClick",\n    value: function handleBackButtonClick() {\n      if (this.props.panelHistory.length == 0) {\n        return;\n      }\n\n      this.props.onPanelBack();\n    }\n  }, {\n    key: "handleAnswerChange",\n    value: function handleAnswerChange(questionId, questionAnswer, validations, validateOn, questionSetId) {\n      this.props.onAnswerChange(questionId, questionAnswer, questionSetId);\n      this.setState({\n        validationErrors: external_lodash_default.a.chain(this.state.validationErrors).set(questionId, []).value()\n      });\n\n      if (validateOn === \'change\') {\n        this.handleAnswerValidate(questionId, questionAnswer, validations);\n      }\n    }\n  }, {\n    key: "handleQuestionBlur",\n    value: function handleQuestionBlur(questionId, questionAnswer, validations, validateOn) {\n      if (validateOn === \'blur\') {\n        this.handleAnswerValidate(questionId, questionAnswer, validations);\n      }\n    }\n  }, {\n    key: "handleInputKeyDown",\n    value: function handleInputKeyDown(e) {\n      if (external_keycodez_default.a[e.keyCode] === \'enter\') {\n        e.preventDefault();\n        this.handleMainButtonClick.call(this);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this4 = this;\n\n      var questionSets = this.props.questionSets.map(function (questionSetMeta) {\n        var questionSet = external_lodash_default.a.find(_this4.props.schema.questionSets, {\n          questionSetId: questionSetMeta.questionSetId\n        });\n\n        if (!questionSet) {\n          return undefined;\n        }\n\n        return external_react_default.a.createElement(src_questionSet, {\n          key: questionSet.questionSetId,\n          id: questionSet.questionSetId,\n          name: questionSet.name,\n          questionSetHeader: questionSet.questionSetHeader,\n          questionSetText: questionSet.questionSetText,\n          questions: questionSet.questions,\n          classes: _this4.props.classes,\n          questionAnswers: _this4.props.questionAnswers,\n          renderError: _this4.props.renderError,\n          renderRequiredAsterisk: _this4.props.renderRequiredAsterisk,\n          validationErrors: _this4.state.validationErrors,\n          onAnswerChange: _this4.handleAnswerChange.bind(_this4),\n          onQuestionBlur: _this4.handleQuestionBlur.bind(_this4),\n          onKeyDown: _this4.handleInputKeyDown.bind(_this4)\n        });\n      });\n      return external_react_default.a.createElement("div", {\n        className: this.props.classes.questionPanel\n      }, typeof this.props.panelHeader !== \'undefined\' || typeof this.props.panelText !== \'undefined\' ? external_react_default.a.createElement("div", {\n        className: this.props.classes.questionPanelHeaderContainer\n      }, typeof this.props.panelHeader !== \'undefined\' ? external_react_default.a.createElement("h3", {\n        className: this.props.classes.questionPanelHeaderText\n      }, this.props.panelHeader) : undefined, typeof this.props.panelText !== \'undefined\' ? external_react_default.a.createElement("p", {\n        className: this.props.classes.questionPanelText\n      }, this.props.panelText) : undefined) : undefined, external_react_default.a.createElement("div", {\n        className: this.props.classes.questionSets\n      }, questionSets), external_react_default.a.createElement("div", {\n        className: this.props.classes.buttonBar\n      }, this.props.panelHistory.length > 1 && !this.props.backButton.disabled ? external_react_default.a.createElement(src_button, {\n        text: this.props.backButton.text || \'Back\',\n        onClick: this.handleBackButtonClick.bind(this),\n        className: this.props.classes.backButton\n      }) : undefined, !this.props.button.disabled ? external_react_default.a.createElement(src_button, {\n        text: this.props.button.text,\n        onClick: this.handleMainButtonClick.bind(this),\n        className: this.props.classes.controlButton\n      }) : undefined));\n    }\n  }]);\n\n  return QuestionPanel;\n}(external_react_default.a.Component);\n\nquestionPanel_QuestionPanel.defaultProps = {\n  validationErrors: {},\n  schema: {},\n  classes: {},\n  panelId: undefined,\n  panelIndex: undefined,\n  panelHeader: undefined,\n  panelText: undefined,\n  action: {\n    default: {},\n    conditions: []\n  },\n  button: {\n    text: \'Submit\'\n  },\n  backButton: {\n    text: \'Back\'\n  },\n  questionSets: [],\n  questionAnswers: {},\n  renderError: undefined,\n  renderRequiredAsterisk: undefined,\n  onAnswerChange: function onAnswerChange() {},\n  onSwitchPanel: function onSwitchPanel() {},\n  onPanelBack: function onPanelBack() {},\n  panelHistory: []\n};\n/* harmony default export */ var questionPanel = (questionPanel_QuestionPanel);\n// CONCATENATED MODULE: ./src/index.js\nfunction src_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { src_typeof = function _typeof(obj) { return typeof obj; }; } else { src_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return src_typeof(obj); }\n\nfunction src_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction src_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction src_createClass(Constructor, protoProps, staticProps) { if (protoProps) src_defineProperties(Constructor.prototype, protoProps); if (staticProps) src_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction src_possibleConstructorReturn(self, call) { if (call && (src_typeof(call) === "object" || typeof call === "function")) { return call; } return src_assertThisInitialized(self); }\n\nfunction src_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction src_getPrototypeOf(o) { src_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return src_getPrototypeOf(o); }\n\nfunction src_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) src_setPrototypeOf(subClass, superClass); }\n\nfunction src_setPrototypeOf(o, p) { src_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return src_setPrototypeOf(o, p); }\n\n // import ReactDOM from \'react-dom\';\n\n\n\n\n\nvar src_Winterfell =\n/*#__PURE__*/\nfunction (_React$Component) {\n  src_inherits(Winterfell, _React$Component);\n\n  function Winterfell(props) {\n    var _this;\n\n    src_classCallCheck(this, Winterfell);\n\n    _this = src_possibleConstructorReturn(this, src_getPrototypeOf(Winterfell).call(this, props));\n    _this.formComponent = null; // Set our default values for props.\n\n    var props = external_lodash_default.a.extend({\n      schema: {\n        formPanels: [],\n        questionPanels: [],\n        questionSets: [],\n        classes: {}\n      },\n      questionAnswers: {},\n      ref: \'form\',\n      encType: \'application/x-www-form-urlencoded\',\n      method: \'POST\',\n      action: \'\',\n      panelId: undefined,\n      disableSubmit: false,\n      renderError: undefined,\n      renderRequiredAsterisk: undefined\n    }, _this.props);\n\n    _this.panelHistory = [];\n\n    var schema = external_lodash_default.a.extend({\n      classes: {},\n      formPanels: [],\n      questionPanels: [],\n      questionSets: []\n    }, props.schema);\n\n    schema.formPanels = schema.formPanels.sort(function (a, b) {\n      return a.index > b.index;\n    });\n    var panelId = typeof props.panelId !== \'undefined\' ? props.panelId : schema.formPanels.length > 0 ? schema.formPanels[0].panelId : undefined;\n    var currentPanel = typeof schema !== \'undefined\' && typeof schema.formPanels !== \'undefined\' && typeof panelId !== \'undefined\' ? external_lodash_default.a.find(schema.formPanels, function (panel) {\n      return panel.panelId == panelId;\n    }) : undefined;\n\n    if (!currentPanel) {\n      throw new Error(\'Winterfell: Could not find initial panel and failed to render.\');\n    }\n\n    _this.state = {\n      schema: schema,\n      currentPanel: currentPanel,\n      action: props.action,\n      questionAnswers: props.questionAnswers\n    };\n    return _this;\n  }\n\n  src_createClass(Winterfell, [{\n    key: "componentWillReceiveProps",\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      this.setState({\n        action: nextProps.action,\n        schema: nextProps.schema,\n        questionAnswers: Object.assign({}, nextProps.questionAnswers, this.state.questionAnswers)\n      }, function () {\n        if (nextProps.panelId !== undefined) {\n          _this2.handleSwitchPanel(nextProps.panelId, true);\n        }\n      });\n    }\n  }, {\n    key: "handleAnswerChange",\n    value: function handleAnswerChange(questionId, questionAnswer, questionSetId) {\n      var questionAnswers = external_lodash_default.a.chain(this.state.questionAnswers).set(questionId, questionAnswer).value();\n\n      this.removeEmptyAnswers(questionAnswers, questionId, questionAnswer, questionSetId);\n      this.setState({\n        questionAnswers: questionAnswers\n      }, this.props.onUpdate.bind(null, questionAnswers));\n    }\n  }, {\n    key: "removeEmptyAnswers",\n    value: function removeEmptyAnswers(questionAnswers, questionId, questionAnswer, questionSetId) {\n      var _this3 = this;\n\n      // get the questionSet where replied\n      var qs = this.props.schema.questionSets.filter(function (qs) {\n        return qs.questionSetId === questionSetId;\n      });\n\n      if (qs.length === 0) {\n        return;\n      } // get the answered question\n\n\n      var reply = this.searchQuestion(qs[0].questions, questionId);\n\n      if (reply.length === 0) {\n        return;\n      } // if don\'t have options (?) nothing to do\n\n\n      if (!reply[0].input.options) {\n        return;\n      } // get the options that *not match* the answered question\n\n\n      var answ = \'\';\n\n      if (questionAnswer instanceof Array) {\n        answ = reply[0].input.options.filter(function (o) {\n          return external_lodash_default.a.findIndex(questionAnswer, function (x) {\n            return o.value === x;\n          }) < 0;\n        });\n      } else {\n        answ = reply[0].input.options.filter(function (o) {\n          return o.value !== questionAnswer;\n        });\n      } // lets go\n\n\n      answ.forEach(function (a) {\n        _this3.removeAnswers(questionAnswers, a.conditionalQuestions);\n      });\n      var rpl = questionAnswers[reply[0].questionId];\n\n      if (rpl instanceof Array && rpl.length === 0) {\n        delete questionAnswers[reply[0].questionId];\n      }\n    } // Transverse the question down to the selected one\n\n  }, {\n    key: "searchQuestion",\n    value: function searchQuestion(questions, questionId) {\n      var _this4 = this;\n\n      var r = questions.filter(function (q) {\n        return q.questionId === questionId;\n      });\n\n      if (r.length === 1) {\n        return r;\n      }\n\n      questions.every(function (q) {\n        var x = q.input.options.every(function (o) {\n          if (o.conditionalQuestions.length > 0) {\n            r = _this4.searchQuestion(o.conditionalQuestions, questionId);\n            return r.length === 0;\n          } else {\n            return true;\n          }\n        });\n        return r.length === 0;\n      });\n      return r;\n    } // down the rabit hole removing all the answers\n\n  }, {\n    key: "removeAnswers",\n    value: function removeAnswers(questionAnswers, questions) {\n      var _this5 = this;\n\n      questions.forEach(function (cq) {\n        cq.input.options.forEach(function (o) {\n          _this5.removeAnswers(questionAnswers, o.conditionalQuestions);\n        });\n        delete questionAnswers[cq.questionId];\n      });\n    }\n  }, {\n    key: "handleSwitchPanel",\n    value: function handleSwitchPanel(panelId, preventHistory) {\n      var panel = external_lodash_default.a.find(this.props.schema.formPanels, {\n        panelId: panelId\n      });\n\n      if (!panel) {\n        throw new Error(\'Winterfell: Tried to switch to panel "\' + panelId + \'", which does not exist.\');\n      }\n\n      if (!preventHistory) {\n        this.panelHistory.push(panel.panelId);\n      }\n\n      this.setState({\n        currentPanel: panel\n      }, this.props.onSwitchPanel.bind(null, panel));\n    }\n  }, {\n    key: "handleBackButtonClick",\n    value: function handleBackButtonClick() {\n      this.panelHistory.pop();\n      this.handleSwitchPanel.call(this, this.panelHistory[this.panelHistory.length - 1], true);\n    }\n  }, {\n    key: "handleSubmit",\n    value: function handleSubmit(action) {\n      var _this6 = this;\n\n      if (this.props.disableSubmit) {\n        this.props.onSubmit(this.state.questionAnswers, action);\n        return;\n      }\n      /*\n       * If we are not disabling the functionality of the form,\n       * we need to set the action provided in the form, then submit.\n       */\n\n\n      this.setState({\n        action: action\n      }, function () {\n        if (!_this6.formComponent) {\n          return;\n        }\n\n        _this6.formComponent.submit();\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this7 = this;\n\n      var currentPanel = external_lodash_default.a.find(this.state.schema.questionPanels, function (panel) {\n        return panel.panelId == _this7.state.currentPanel.panelId;\n      });\n\n      return external_react_default.a.createElement("form", {\n        method: this.props.method,\n        encType: this.props.encType,\n        action: this.state.action,\n        ref: function ref(_ref) {\n          return _this7.formComponent = _ref;\n        },\n        className: this.state.schema.classes.form\n      }, external_react_default.a.createElement("div", {\n        className: this.state.schema.classes.questionPanels\n      }, external_react_default.a.createElement(questionPanel, {\n        schema: this.state.schema,\n        classes: this.state.schema.classes,\n        panelId: currentPanel.panelId,\n        panelIndex: currentPanel.panelIndex,\n        panelHeader: currentPanel.panelHeader,\n        panelText: currentPanel.panelText,\n        action: currentPanel.action,\n        button: currentPanel.button,\n        backButton: currentPanel.backButton,\n        questionSets: currentPanel.questionSets,\n        questionAnswers: this.state.questionAnswers,\n        panelHistory: this.panelHistory,\n        renderError: this.props.renderError,\n        renderRequiredAsterisk: this.props.renderRequiredAsterisk,\n        onAnswerChange: this.handleAnswerChange.bind(this),\n        onPanelBack: this.handleBackButtonClick.bind(this),\n        onSwitchPanel: this.handleSwitchPanel.bind(this),\n        onSubmit: this.handleSubmit.bind(this)\n      })));\n    }\n  }, {\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.panelHistory.push(this.state.currentPanel.panelId);\n      this.props.onRender();\n    }\n  }]);\n\n  return Winterfell;\n}(external_react_default.a.Component);\n\nsrc_Winterfell.propTypes = {\n  schema: external_prop_types_default.a.object.isRequired,\n  panelId: external_prop_types_default.a.string,\n  ref: external_prop_types_default.a.string,\n  encType: external_prop_types_default.a.string,\n  method: external_prop_types_default.a.string,\n  action: external_prop_types_default.a.string,\n  disableSubmit: external_prop_types_default.a.bool,\n  questionAnswers: external_prop_types_default.a.object,\n  renderError: external_prop_types_default.a.func,\n  renderRequiredAsterisk: external_prop_types_default.a.func\n};\nsrc_Winterfell.inputTypes = __webpack_require__(6);\nsrc_Winterfell.errorMessages = __webpack_require__(3);\nsrc_Winterfell.validation = __webpack_require__(4);\nsrc_Winterfell.addInputType = src_Winterfell.inputTypes.addInputType;\nsrc_Winterfell.addInputTypes = src_Winterfell.inputTypes.addInputTypes;\nsrc_Winterfell.addErrorMessage = src_Winterfell.errorMessages.addErrorMessage;\nsrc_Winterfell.addErrorMessages = src_Winterfell.errorMessages.addErrorMessages;\nsrc_Winterfell.addValidationMethod = src_Winterfell.validation.addValidationMethod;\nsrc_Winterfell.addValidationMethods = src_Winterfell.validation.addValidationMethods;\nsrc_Winterfell.purgeQuestionAnswers = src_Winterfell.validation.purgeQuestionAnswers;\nsrc_Winterfell.defaultProps = {\n  onSubmit: function onSubmit() {},\n  onUpdate: function onUpdate() {},\n  onSwitchPanel: function onSwitchPanel() {},\n  onRender: function onRender() {}\n};\n/* harmony default export */ var src = __webpack_exports__["default"] = (src_Winterfell);\n\n//# sourceURL=webpack://Winterfell/./src/index.js_+_4_modules?')}]);